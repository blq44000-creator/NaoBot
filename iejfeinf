import SwiftUI
import CoreLocation
import Combine

// ============================================================================
// MARK: - 1. CONFIGURATION
// ============================================================================

let GEMINI_API_KEY = "" // ðŸ”´ COLLEZ VOTRE CLÃ‰ ICI

// ============================================================================
// MARK: - 2. MODÃˆLES
// ============================================================================

struct Arret: Identifiable, Hashable, Sendable {
    var id = UUID()
    let codeLieu: String
    let libelle: String
    let latitude: Double
    let longitude: Double
    var distance: String? = nil
    
    static func == (lhs: Arret, rhs: Arret) -> Bool { lhs.codeLieu == rhs.codeLieu }
    func hash(into hasher: inout Hasher) { hasher.combine(codeLieu) }
}

// ModÃ¨le pour le regroupement (Ligne + Direction)
struct LignePassage: Identifiable, Hashable, Sendable {
    var id = UUID()
    let numLigne: String
    let terminus: String
    let tempsAffiche: String // "5 min" ou "14:23"
    let sens: Int
    let isRealTime: Bool
}

// ModÃ¨le Horaire Fixe (Grille)
struct HorairePassage: Identifiable, Hashable, Sendable {
    var id = UUID()
    let heure: String // "14:24"
    let isRealTime: Bool
    let isPast: Bool
}

struct TempsAttente: Codable, Identifiable, Sendable {
    var id = UUID()
    let sens: Int
    let terminus: String
    let temps: String
    let ligne: LigneAPI?
    
    var isRealTime: Bool { temps == "Proche" || temps.contains("mn") }
    
    private enum CodingKeys: String, CodingKey {
        case sens, terminus, temps, ligne
    }
}

struct LigneAPI: Codable, Sendable {
    let numLigne: String
}

struct TrafficInfo: Identifiable, Sendable {
    var id = UUID()
    let titre: String
    let message: String
    let ligne: String?
}

struct TrafficResponseV2: Codable, Sendable {
    let results: [TrafficRecordV2]
}

struct TrafficRecordV2: Codable, Sendable {
    let intitule: String?
    let libelle: String?
    let resume: String?
    let description: String?
    let nature: String?
    let type: String?
    let ligne: [TrafficLineV2]?
}

struct TrafficLineV2: Codable, Sendable {
    let num_ligne: String?
}

// ============================================================================
// MARK: - 3. GESTIONNAIRE DE TRANSPORT
// ============================================================================

@MainActor
class TransportManager: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var locationStatus: String = "Recherche GPS..."
    @Published var allStops: [Arret] = []
    @Published var nearbyStops: [Arret] = []
    @Published var searchRadius: Double = 400 
    
    // DonnÃ©es
    @Published var waitTimes: [TempsAttente] = [] 
    @Published var lineSchedule: [HorairePassage] = [] 
    
    @Published var trafficInfos: [TrafficInfo] = []
    @Published var userLocation: CLLocation?
    @Published var isLoading: Bool = false
    @Published var databaseLoaded: Bool = false

    private let locationManager = CLLocationManager()
    
    override init() {
        super.init()
        loadGTFSData()
        
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 50
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
        
        Task { await fetchTraffic() }
    }
    
    // --- 1. GTFS LOCAL ---
    func loadGTFSData() {
        print("ðŸ“‚ Chargement stops.txt...")
        guard let path = Bundle.main.path(forResource: "stops", ofType: "txt") else {
            print("âŒ ERREUR : stops.txt introuvable !")
            return
        }
        
        Task.detached(priority: .userInitiated) {
            do {
                let content = try String(contentsOfFile: path, encoding: .utf8)
                let lines = content.components(separatedBy: .newlines)
                var uniqueStops = [String: Arret]()
                
                for (i, line) in lines.enumerated() {
                    if i == 0 || line.isEmpty { continue }
                    let parts = self.parseCSVLine(line)
                    if parts.count >= 5, let lat = Double(parts[3]), let lon = Double(parts[4]) {
                        let id = parts[0].replacingOccurrences(of: "\"", with: "")
                        let name = parts[1].replacingOccurrences(of: "\"", with: "")
                        
                        if uniqueStops[name] == nil {
                            uniqueStops[name] = Arret(codeLieu: id, libelle: name, latitude: lat, longitude: lon)
                        }
                    }
                }
                let sorted = Array(uniqueStops.values).sorted { $0.libelle < $1.libelle }
                await MainActor.run {
                    self.allStops = sorted
                    self.databaseLoaded = true
                    self.recalculateNearbyStops()
                }
            } catch { print("âŒ Erreur lecture: \(error)") }
        }
    }
    
    nonisolated private func parseCSVLine(_ line: String) -> [String] {
        var result: [String] = []
        var current = ""
        var insideQuotes = false
        for char in line {
            if char == "\"" { insideQuotes.toggle() }
            else if char == "," && !insideQuotes { result.append(current); current = "" }
            else { current.append(char) }
        }
        result.append(current)
        return result
    }
    
    // --- 2. GPS & RAYON ---
    nonisolated func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let loc = locations.last else { return }
        Task { @MainActor in
            self.userLocation = loc
            self.locationStatus = "GPS Actif"
            self.recalculateNearbyStops()
        }
    }
    
    nonisolated func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        Task { @MainActor in self.locationStatus = "GPS Inactif" }
    }
    
    func expandRadius() {
        self.searchRadius = 1500
        self.recalculateNearbyStops()
    }
    
    func recalculateNearbyStops() {
        guard let userLoc = self.userLocation, !self.allStops.isEmpty else { return }
        let radius = self.searchRadius
        
        Task.detached(priority: .userInitiated) {
            let stops = await self.allStops
            let nearby = stops.compactMap { stop -> Arret? in
                let stopLoc = CLLocation(latitude: stop.latitude, longitude: stop.longitude)
                let dist = userLoc.distance(from: stopLoc)
                if dist <= radius {
                    var s = stop
                    s.distance = "\(Int(dist))m"
                    return s
                }
                return nil
            }
            let sorted = nearby.sorted {
                let d1 = Int($0.distance?.replacingOccurrences(of: "m", with: "") ?? "9999") ?? 9999
                let d2 = Int($1.distance?.replacingOccurrences(of: "m", with: "") ?? "9999") ?? 9999
                return d1 < d2
            }
            await MainActor.run { self.nearbyStops = sorted }
        }
    }
    
    // --- 3. API TEMPS RÃ‰EL ---
    func fetchWaitTimes(codeLieu: String) async {
        self.isLoading = true
        self.waitTimes = []
        
        guard let url = URL(string: "https://open.tan.fr/ewp/tempsattente.json/\(codeLieu)") else { return }
        
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            let decoded = try JSONDecoder().decode([TempsAttente].self, from: data)
            self.waitTimes = decoded
            self.isLoading = false
        } catch {
            print("âš ï¸ Erreur TR: \(error)")
            self.isLoading = false
        }
    }
    
    // --- 4. GÃ‰NÃ‰RATEUR D'HORAIRES FIXES (MÃ‰THODE ROBUSTE) ---
    // Cette fonction transforme les temps d'attente ("5 mn") en heure fixe ("14:25")
    // et projette les horaires suivants pour simuler une fiche complÃ¨te.
    func generateScheduleFromRealTime(line: LignePassage) {
        var schedules: [HorairePassage] = []
        let now = Date()
        let calendar = Calendar.current
        let formatter = DateFormatter(); formatter.dateFormat = "HH:mm"
        
        // 1. RÃ©cupÃ©rer les prochains passages rÃ©els de l'API
        let realPassages = self.waitTimes.filter {
            $0.ligne?.numLigne == line.numLigne && $0.terminus == line.terminus
        }
        
        var lastDate = now
        
        for passage in realPassages {
            var date: Date?
            
            if passage.temps == "Proche" {
                date = now
            } else if let min = Int(passage.temps.replacingOccurrences(of: "mn", with: "")) {
                date = now.addingTimeInterval(TimeInterval(min * 60))
            }
            
            if let d = date {
                lastDate = d // On garde la derniÃ¨re heure connue pour projeter la suite
                schedules.append(HorairePassage(
                    heure: formatter.string(from: d),
                    isRealTime: true,
                    isPast: false
                ))
            }
        }
        
        // 2. Si on a trouvÃ© des passages, on projette la suite (ThÃ©orique)
        // Sinon, c'est que c'est la fin de service.
        if !schedules.isEmpty {
            // FrÃ©quence estimÃ©e selon la ligne
            let interval = (["1","2","3","4","5","C1","C2","C3","C6"].contains(line.numLigne)) ? 10.0 * 60 : 20.0 * 60
            
            for i in 1...15 { // On ajoute 15 prochains passages thÃ©oriques
                let nextDate = lastDate.addingTimeInterval(Double(i) * interval)
                
                // On s'arrÃªte Ã  1h du matin
                let hour = calendar.component(.hour, from: nextDate)
                if hour >= 1 && hour < 4 { break }
                
                schedules.append(HorairePassage(
                    heure: formatter.string(from: nextDate),
                    isRealTime: false,
                    isPast: false
                ))
            }
        }
        
        self.lineSchedule = schedules
    }
    
    // --- TRAFIC ---
    func fetchTraffic() async {
        guard let url = URL(string: "https://data.nantesmetropole.fr/api/explore/v2.1/catalog/datasets/244400404_info-trafic-tan-temps-reel/records?limit=50") else { return }
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            let response = try JSONDecoder().decode(TrafficResponseV2.self, from: data)
            let infos = response.results.compactMap { r -> TrafficInfo? in
                let title = r.intitule ?? r.libelle ?? "Info RÃ©seau"
                let msg = [r.resume, r.description, r.nature, r.type].compactMap { $0 }.first ?? "Voir site TAN."
                return TrafficInfo(titre: title, message: msg, ligne: r.ligne?.first?.num_ligne)
            }
            self.trafficInfos = infos
        } catch { print("âŒ Trafic: \(error)") }
    }
    
    // --- IA ---
    func askGemini(prompt: String, context: String, completion: @escaping (String) -> Void) {
        guard !GEMINI_API_KEY.isEmpty else { completion("ClÃ© manquante"); return }
        let url = URL(string: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=\(GEMINI_API_KEY)")!
        var req = URLRequest(url: url); req.httpMethod = "POST"; req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let body: [String: Any] = ["contents": [["parts": [["text": prompt]]]], "systemInstruction": ["parts": [["text": context]]]]
        req.httpBody = try? JSONSerialization.data(withJSONObject: body)
        URLSession.shared.dataTask(with: req) { d, _, _ in
            guard let d=d, let j=try? JSONSerialization.jsonObject(with: d) as? [String:Any],
                  let c = j["candidates"] as? [[String:Any]], let p = c.first?["content"] as? [String:Any],
                  let t = (p["parts"] as? [[String:Any]])?.first?["text"] as? String else { completion("Err IA"); return }
            DispatchQueue.main.async { completion(t) }
        }.resume()
    }
}

// ============================================================================
// MARK: - 4. VUES UI
// ============================================================================

struct ContentView: View {
    @StateObject var manager = TransportManager()
    @State private var selection = 0
    
    init() { UITabBar.appearance().backgroundColor = UIColor.systemBackground }
    
    var body: some View {
        TabView(selection: $selection) {
            HomeView(manager: manager).tabItem { Label("Horaires", systemImage: "clock.fill") }.tag(0)
            TrafficView(manager: manager).tabItem { Label("Trafic", systemImage: "exclamationmark.triangle.fill") }.tag(1)
            NaoBotView(manager: manager).tabItem { Label("NaoBot", systemImage: "message.fill") }.tag(2)
        }
        .accentColor(Color(hex: "009640"))
    }
}

struct HomeView: View {
    @ObservedObject var manager: TransportManager
    @State private var searchText = ""
    
    var listSource: [Arret] {
        if searchText.isEmpty { return manager.nearbyStops }
        return manager.allStops.filter { $0.libelle.localizedCaseInsensitiveContains(searchText) }
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                Color(uiColor: .systemGroupedBackground).ignoresSafeArea()
                
                VStack(spacing: 0) {
                    // HEADER
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text("Transport").font(.system(size: 34, weight: .bold))
                            Spacer()
                            if !manager.databaseLoaded { HStack { ProgressView(); Text(" Chargement...").font(.caption) } }
                            else { Text("\(manager.allStops.count) arrÃªts").font(.caption).foregroundColor(.gray) }
                        }
                        HStack {
                            Image(systemName: "magnifyingglass").foregroundColor(.gray)
                            TextField("Rechercher...", text: $searchText)
                        }
                        .padding(12).background(Color.white).cornerRadius(12)
                    }.padding().background(.ultraThinMaterial)
                    
                    // LISTE
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            HStack {
                                Text(searchText.isEmpty ? "AUTOUR DE MOI (<\(Int(manager.searchRadius))m)" : "RÃ‰SULTATS")
                                    .font(.caption).fontWeight(.bold).foregroundColor(.gray)
                                Spacer()
                            }
                            .padding(.horizontal).padding(.top, 10)
                            
                            if listSource.isEmpty && manager.databaseLoaded && searchText.isEmpty {
                                // Bouton pour Ã©largir si vide
                                VStack(spacing: 15) {
                                    Text("Aucun arrÃªt proche.").foregroundColor(.gray)
                                    Button(action: { manager.expandRadius() }) {
                                        Text("Ã‰largir la recherche (1.5 km)")
                                            .fontWeight(.bold)
                                            .padding()
                                            .background(Color(hex: "009640"))
                                            .foregroundColor(.white)
                                            .cornerRadius(10)
                                    }
                                }.padding(.top, 40)
                            } else {
                                ForEach(listSource.prefix(50)) { stop in
                                    NavigationLink(destination: StopDetailView(stop: stop, manager: manager)) {
                                        StopRow(stop: stop)
                                    }.buttonStyle(PlainButtonStyle())
                                }
                            }
                            
                            // Bouton "Voir plus" en bas de liste
                            if !listSource.isEmpty && searchText.isEmpty && manager.searchRadius < 1000 {
                                Button(action: { manager.expandRadius() }) {
                                    Text("Voir plus d'arrÃªts (+)")
                                        .font(.caption).fontWeight(.bold)
                                        .padding()
                                        .frame(maxWidth: .infinity)
                                        .background(Color.gray.opacity(0.1))
                                        .foregroundColor(.primary)
                                        .cornerRadius(8)
                                }
                                .padding()
                            }
                            
                        }.padding(.horizontal).padding(.bottom, 20)
                    }
                }
            }.navigationBarHidden(true)
        }
    }
}

struct StopRow: View {
    let stop: Arret
    var body: some View {
        HStack {
            ZStack {
                Circle().fill(Color.white).frame(width: 44, height: 44).shadow(radius: 1)
                Image(systemName: "bus.fill").foregroundColor(Color(hex: "009640"))
            }
            VStack(alignment: .leading, spacing: 2) {
                Text(stop.libelle).font(.headline).foregroundColor(.primary)
                if let dist = stop.distance {
                    Text(dist).font(.caption).fontWeight(.bold).foregroundColor(Color(hex: "009640"))
                        .padding(.horizontal, 6).padding(.vertical, 2)
                        .background(Color(hex: "009640").opacity(0.1)).cornerRadius(4)
                }
            }
            Spacer()
            Image(systemName: "chevron.right").foregroundColor(.gray)
        }
        .padding().background(Color.white).cornerRadius(16).shadow(radius: 1, y: 1)
    }
}

struct StopDetailView: View {
    let stop: Arret
    @ObservedObject var manager: TransportManager
    
    var groupedLines: [LignePassage] {
        var groups = [String: LignePassage]()
        for t in manager.waitTimes {
            guard let num = t.ligne?.numLigne else { continue }
            let key = "\(num)-\(t.terminus)"
            if groups[key] == nil {
                groups[key] = LignePassage(
                    numLigne: num,
                    terminus: t.terminus,
                    tempsAffiche: t.temps,
                    sens: t.sens,
                    isRealTime: t.isRealTime
                )
            }
        }
        return Array(groups.values).sorted { $0.numLigne < $1.numLigne }
    }
    
    var body: some View {
        ZStack {
            Color(uiColor: .systemGroupedBackground).ignoresSafeArea()
            
            List {
                if manager.isLoading {
                    HStack { Spacer(); ProgressView(); Spacer() }.listRowBackground(Color.clear)
                } else if manager.waitTimes.isEmpty {
                    VStack(alignment: .center, spacing: 10) {
                        Image(systemName: "moon.zzz.fill").font(.largeTitle).foregroundColor(.gray)
                        Text("Fin de Service").font(.headline)
                        Text("Aucun passage dÃ©tectÃ©.")
                            .font(.caption).foregroundColor(.secondary)
                    }
                    .frame(maxWidth: .infinity).padding(.vertical, 40).listRowBackground(Color.clear)
                } else {
                    ForEach(groupedLines) { line in
                        NavigationLink(destination: FullScheduleView(line: line, manager: manager)) {
                            HStack {
                                LineBadge(num: line.numLigne)
                                VStack(alignment: .leading) {
                                    Text("Vers \(line.terminus)").font(.headline)
                                }
                                Spacer()
                                VStack(alignment: .trailing) {
                                    Text(line.tempsAffiche)
                                        .font(.title3).bold()
                                        .foregroundColor(line.tempsAffiche == "Proche" ? Color(hex: "009640") : .primary)
                                    if line.isRealTime {
                                        Text("Live").font(.caption2).foregroundColor(.green)
                                    }
                                }
                            }.padding(.vertical, 4)
                        }
                    }
                }
            }
            .listStyle(InsetGroupedListStyle())
            .refreshable { await manager.fetchWaitTimes(codeLieu: stop.codeLieu) }
        }
        .navigationTitle(stop.libelle)
        .onAppear { Task { await manager.fetchWaitTimes(codeLieu: stop.codeLieu) } }
    }
}

struct FullScheduleView: View {
    let line: LignePassage
    @ObservedObject var manager: TransportManager
    
    var body: some View {
        List {
            Section(header: Text("DÃ‰PARTS Ã€ VENIR (ESTIMÃ‰S)")) {
                if manager.lineSchedule.isEmpty {
                    Text("Fin de service.").foregroundColor(.gray)
                } else {
                    ForEach(manager.lineSchedule) { horaire in
                        HStack {
                            Text(horaire.heure).font(.title2).bold()
                            Spacer()
                            if horaire.isRealTime {
                                Text("Live").font(.caption).padding(6).background(Color.green.opacity(0.1)).foregroundColor(Color(hex: "009640")).cornerRadius(8)
                            } else {
                                Text("ThÃ©orique").font(.caption).foregroundColor(.gray)
                            }
                        }
                    }
                }
            }
        }
        .navigationTitle("Ligne \(line.numLigne)")
        .onAppear {
            manager.generateScheduleFromRealTime(line: line)
        }
    }
}

struct TrafficView: View {
    @ObservedObject var manager: TransportManager
    @State private var aiSummary: String? = nil
    @State private var loadingAI = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    Button(action: summarize) {
                        HStack { Image(systemName: "sparkles"); Text(loadingAI ? "..." : "RÃ©sumÃ© IA") }
                        .frame(maxWidth: .infinity).padding().background(Color.green).foregroundColor(.white).cornerRadius(12)
                    }.listRowBackground(Color.clear).listRowInsets(EdgeInsets())
                    if let s = aiSummary { Text(s).padding().background(Color.green.opacity(0.1)).cornerRadius(8) }
                }
                Section(header: Text("PERTURBATIONS")) {
                    ForEach(manager.trafficInfos) { info in
                        VStack(alignment: .leading) {
                            HStack {
                                if let l = info.ligne { LineBadge(num: l) }
                                Text(info.titre).font(.headline)
                            }
                            Text(info.message).font(.caption).foregroundColor(.secondary)
                        }.padding(.vertical, 4)
                    }
                }
            }.navigationTitle("Info Trafic")
        }
    }
    func summarize() {
        loadingAI = true
        let t = manager.trafficInfos.prefix(10).map { "\($0.titre): \($0.message)" }.joined(separator: "\n")
        manager.askGemini(prompt: "RÃ©sumÃ© drÃ´le trafic Nantes: \(t)", context: "Conducteur") { self.aiSummary=$0; self.loadingAI=false }
    }
}

struct NaoBotView: View {
    @ObservedObject var manager: TransportManager
    @State private var txt = ""; @State private var msgs = [ChatMessage(text: "Salut !", isUser: false)]
    var body: some View {
        VStack {
            ScrollView {
                VStack(alignment: .leading) {
                    ForEach(msgs) { m in
                        HStack {
                            if m.isUser { Spacer() }
                            Text(m.text).padding().background(m.isUser ? Color(hex: "009640") : Color(uiColor: .secondarySystemBackground))
                                .foregroundColor(m.isUser ? .white : .primary).cornerRadius(16)
                            if !m.isUser { Spacer() }
                        }
                    }
                }.padding()
            }
            HStack {
                TextField("Message...", text: $txt).textFieldStyle(RoundedBorderTextFieldStyle())
                Button(action: send) { Image(systemName: "paperplane.fill").foregroundColor(Color(hex: "009640")) }
            }.padding()
        }
    }
    func send() {
        let q=txt; txt=""; msgs.append(ChatMessage(text: q, isUser: true))
        manager.askGemini(prompt: q, context: "Assistant TAN") { msgs.append(ChatMessage(text: $0, isUser: false)) }
    }
}

struct ChatMessage: Identifiable { let id = UUID(); let text: String; let isUser: Bool }

struct LineBadge: View {
    let num: String
    var color: Color {
        switch num {
        case "1": return Color(hex: "009640"); case "2": return Color(hex: "E30613"); case "3": return Color(hex: "2D2F92")
        case "4", "5": return Color(hex: "7A2182"); case let x where x.hasPrefix("C"): return Color(hex: "FFCC00")
        default: return .gray
        }
    }
    var body: some View {
        Text(num).font(.system(size: 14, weight: .bold)).frame(width: 32, height: 32)
            .background(color).foregroundColor(num.hasPrefix("C") ? .black : .white).cornerRadius(8)
    }
}

extension Color {
    init(hex: String) {
        let scanner = Scanner(string: hex); var rgbValue: UInt64 = 0; scanner.scanHexInt64(&rgbValue)
        let r = (rgbValue & 0xff0000) >> 16; let g = (rgbValue & 0xff00) >> 8; let b = rgbValue & 0xff
        self.init(red: Double(r) / 0xff, green: Double(g) / 0xff, blue: Double(b) / 0xff)
    }
}
